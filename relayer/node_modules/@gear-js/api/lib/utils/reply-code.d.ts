import { HexString } from '../types/index.js';
interface IReplyCodeReason {
    readonly explanation: string;
}
export declare const enum EReplyCode {
    Success = 0,
    Error = 1
}
/**
 * # Reply Code decoder
 * @param codeBytes reply code
 * @param _specVersion spec version of the Gear runtime
 */
export declare class ReplyCode {
    private _specVersion?;
    private _bytes;
    constructor(codeBytes: Uint8Array | HexString, _specVersion?: number);
    get isSuccess(): boolean;
    get isError(): boolean;
    get successReason(): SuccessReplyReason;
    get errorReason(): ErrorReplyReason;
}
export declare const enum ESuccessReply {
    Auto = 0,
    Manual = 1
}
/**
 * # Success reply reason.
 */
export declare class SuccessReplyReason implements IReplyCodeReason {
    private _bytes;
    constructor(bytes: Uint8Array);
    get explanation(): string;
    get isAuto(): boolean;
    get isManual(): boolean;
}
/**
 * # Error reply reason
 */
export declare class ErrorReplyReason implements IReplyCodeReason {
    private _specVersion?;
    private _bytes;
    constructor(bytes: Uint8Array, _specVersion?: number);
    private _throwUnsupported;
    get explanation(): string;
    get isExecution(): boolean;
    get executionReason(): ExecutionErrorReason;
    /** This option is available only for spec versions before 1800 */
    get isFailedToCreateProgram(): boolean;
    get isUnavailableActor(): boolean;
    get unavailableActorReason(): UnavailableActorErrorReason;
    get isRemovedFromWaitlist(): boolean;
    /** This option is available only for spec versions before 1800 */
    get isReinstrumentationFailure(): boolean;
}
export declare const enum ESimpleExecutionError {
    RanOutOfGas = 0,
    MemoryOverflow = 1,
    BackendError = 2,
    UserspacePanic = 3,
    UnreachableInstruction = 4,
    StackLimitExceeded = 5
}
/**
 * # Execution error reason
 */
export declare class ExecutionErrorReason implements IReplyCodeReason {
    private _bytes;
    constructor(bytes: Uint8Array);
    get explanation(): string;
    get isRanOutOfGas(): boolean;
    get isMemoryOverflow(): boolean;
    get isBackendError(): boolean;
    get isUserspacePanic(): boolean;
    get isUnreachableInstruction(): boolean;
    get isStackLimitExceeded(): boolean;
}
export declare const enum ESimpleUnavailableActorError {
    ProgramExited = 0,
    InitializationFailure = 1,
    Uninitialized = 2,
    ProgramNotCreated = 3,
    ReinstrumentationFailure = 4
}
export declare class UnavailableActorErrorReason implements IReplyCodeReason {
    private _bytes;
    constructor(bytes: Uint8Array);
    private _throwUnsupported;
    get explanation(): string;
    get isProgramExited(): boolean;
    get isInitializationFailure(): boolean;
    get isUninitialized(): boolean;
    get isProgramNotCreated(): boolean;
    get isReinstrumentationFailure(): boolean;
}
export {};
